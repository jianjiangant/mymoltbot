<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>ç”˜ç‰¹å›¾ - MyMoltBot</title>
  <script src="https://unpkg.com/vue@3/dist/vue.global.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/chartjs-adapter-date-fns/dist/chartjs-adapter-date-fns.bundle.min.js"></script>
  <link rel="stylesheet" href="../src/styles/gantt.css">
</head>
<body>
  <div id="app">
    <div class="container">
      <div class="header">
        <h1>ğŸ“Š ç”˜ç‰¹å›¾</h1>
        <p>å¯è§†åŒ–ç®¡ç†å¾…åŠäº‹é¡¹æ—¶é—´å…³ç³»</p>
        <a href="../index.html" class="back-link">â† è¿”å›ä¸»é¡µ</a>
      </div>
      
      <div class="controls">
        <button @click="showAddModal = true" class="add-task-btn">â• æ·»åŠ ä»»åŠ¡</button>
        <div class="view-controls">
          <label>è§†å›¾èŒƒå›´ï¼š</label>
          <select v-model="viewRange" @change="updateChart" class="range-select">
            <option value="week">æœ¬å‘¨</option>
            <option value="month">æœ¬æœˆ</option>
            <option value="quarter">å­£åº¦</option>
          </select>
        </div>
      </div>
      
      <div class="gantt-container">
        <div class="gantt-chart" ref="ganttChart">
          <!-- æ‚¬åœæ•ˆæœå’Œæ‹–æ‹½æ‰‹æŸ„å°†åŠ¨æ€æ·»åŠ åˆ°è¿™é‡Œ -->
        </div>
      </div>
      
      <div class="tasks-list">
        <h3>ä»»åŠ¡åˆ—è¡¨</h3>
        <div class="task-item" v-for="task in tasks" :key="task.id">
          <div class="task-info">
            <strong>{{ task.title }}</strong>
            <div class="task-dates">{{ formatDate(task.startDate) }} - {{ formatDate(task.endDate) }}</div>
            <div class="task-progress">è¿›åº¦: {{ task.progress }}%</div>
          </div>
          <div class="task-actions">
            <button @click="editTask(task)" class="edit-btn">ç¼–è¾‘</button>
            <button @click="prepareDeleteTask(task)" class="delete-btn">åˆ é™¤</button>
          </div>
        </div>
      </div>
    </div>
    
    <!-- æ·»åŠ /ç¼–è¾‘ä»»åŠ¡æ¨¡æ€æ¡† -->
    <div v-if="showAddModal" class="modal-overlay" @click="showAddModal = false">
      <div class="modal-content" @click.stop>
        <h3>{{ editingTask ? 'ç¼–è¾‘ä»»åŠ¡' : 'æ·»åŠ ä»»åŠ¡' }}</h3>
        <form @submit.prevent="saveTask">
          <div class="form-group">
            <label>ä»»åŠ¡åç§°:</label>
            <input 
              v-model="currentTask.title" 
              type="text" 
              class="form-input" 
              required
            />
          </div>
          <div class="form-row">
            <div class="form-group">
              <label>å¼€å§‹æ—¥æœŸ:</label>
              <input 
                v-model="currentTask.startDate" 
                type="datetime-local" 
                class="form-input" 
                required
              />
            </div>
            <div class="form-group">
              <label>ç»“æŸæ—¥æœŸ:</label>
              <input 
                v-model="currentTask.endDate" 
                type="datetime-local" 
                class="form-input" 
                required
              />
            </div>
          </div>
          <div class="form-group">
            <label>è¿›åº¦ (%):</label>
            <input 
              v-model.number="currentTask.progress" 
              type="range" 
              min="0" 
              max="100" 
              class="progress-slider"
            />
            <span class="progress-value">{{ currentTask.progress }}%</span>
          </div>
          <div class="form-actions">
            <button type="submit" class="save-btn">ä¿å­˜</button>
            <button type="button" @click="cancelEdit" class="cancel-btn">å–æ¶ˆ</button>
          </div>
        </form>
      </div>
    </div>
    
    <!-- åˆ é™¤ç¡®è®¤æ¨¡æ€æ¡† -->
    <div v-if="showDeleteModal" class="modal-overlay" @click="showDeleteModal = false">
      <div class="modal-content" @click.stop>
        <h3>ç¡®è®¤åˆ é™¤</h3>
        <p>æ‚¨ç¡®å®šè¦åˆ é™¤ä»»åŠ¡ "{{ taskToDelete?.title }}" å—ï¼Ÿæ­¤æ“ä½œæ— æ³•æ’¤é”€ã€‚</p>
        <div class="form-actions">
          <button @click="confirmDelete" class="save-btn danger">åˆ é™¤</button>
          <button @click="cancelDelete" class="cancel-btn">å–æ¶ˆ</button>
        </div>
      </div>
    </div>
  </div>

  <script>
    // ç­‰å¾…é¡µé¢å®Œå…¨åŠ è½½åå†æ‰§è¡Œ
    document.addEventListener('DOMContentLoaded', function() {
      if (typeof Vue === 'undefined') {
        console.error('Vue is not loaded');
        return;
      }
      
      const { createApp, ref, onMounted, onUnmounted, reactive, watch } = Vue;
      
      createApp({
        setup() {
          // ä»»åŠ¡æ•°æ®
          const tasks = ref(JSON.parse(localStorage.getItem('ganttTasks')) || []);
          const showAddModal = ref(false);
          const showDeleteModal = ref(false);
          const editingTask = ref(null);
          const taskToDelete = ref(null);
          const viewRange = ref('month');
          const ganttChart = ref(null);
          let chartInstance = null;
          
          // æ‹–æ‹½ç›¸å…³å…ƒç´ 
          let hoverOverlay = null;
          let leftHandle = null;
          let rightHandle = null;
          let isUpdating = false; // é˜²æ­¢æ›´æ–°è¿‡ç¨‹ä¸­çš„å†²çª
          
          // ä¿å­˜åˆ°æœ¬åœ°å­˜å‚¨
          const saveToLocalStorage = () => {
            localStorage.setItem('ganttTasks', JSON.stringify(tasks.value));
          };
          
          // å½“å‰ä»»åŠ¡å¯¹è±¡ï¼ˆç”¨äºè¡¨å•ï¼‰
          const currentTask = reactive({
            title: '',
            startDate: '',
            endDate: '',
            progress: 0
          });

          // åˆå§‹åŒ–é»˜è®¤æ•°æ®ï¼ˆå¦‚æœæ²¡æœ‰æ•°æ®ï¼‰
          if (tasks.value.length === 0) {
            tasks.value = [
              {
                id: 1,
                title: 'é¡¹ç›®è§„åˆ’',
                startDate: new Date(Date.now() - 3 * 24 * 60 * 60 * 1000).toISOString().slice(0, 16),
                endDate: new Date(Date.now() + 2 * 24 * 60 * 60 * 1000).toISOString().slice(0, 16),
                progress: 60
              },
              {
                id: 2,
                title: 'éœ€æ±‚åˆ†æ',
                startDate: new Date(Date.now() - 2 * 24 * 60 * 60 * 1000).toISOString().slice(0, 16),
                endDate: new Date(Date.now() + 4 * 24 * 60 * 60 * 1000).toISOString().slice(0, 16),
                progress: 30
              },
              {
                id: 3,
                title: 'å¼€å‘é˜¶æ®µ',
                startDate: new Date(Date.now()).toISOString().slice(0, 16),
                endDate: new Date(Date.now() + 7 * 24 * 60 * 60 * 1000).toISOString().slice(0, 16),
                progress: 0
              },
              {
                id: 4,
                title: 'æµ‹è¯•é˜¶æ®µ',
                startDate: new Date(Date.now() + 6 * 24 * 60 * 60 * 1000).toISOString().slice(0, 16),
                endDate: new Date(Date.now() + 10 * 24 * 60 * 60 * 1000).toISOString().slice(0, 16),
                progress: 0
              }
            ];
            saveToLocalStorage();
          }

          // æ·»åŠ æˆ–ç¼–è¾‘ä»»åŠ¡
          const saveTask = () => {
            if (!currentTask.title || !currentTask.startDate || !currentTask.endDate) {
              alert('è¯·å¡«å†™æ‰€æœ‰å¿…å¡«å­—æ®µ');
              return;
            }
            
            if (new Date(currentTask.startDate) > new Date(currentTask.endDate)) {
              alert('ç»“æŸæ—¥æœŸä¸èƒ½æ—©äºå¼€å§‹æ—¥æœŸ');
              return;
            }
            
            if (editingTask.value) {
              // ç¼–è¾‘ç°æœ‰ä»»åŠ¡
              const index = tasks.value.findIndex(t => t.id === editingTask.value.id);
              if (index !== -1) {
                tasks.value[index] = { ...currentTask, id: editingTask.value.id };
              }
            } else {
              // æ·»åŠ æ–°ä»»åŠ¡
              const newId = tasks.value.length > 0 ? Math.max(...tasks.value.map(t => t.id)) + 1 : 1;
              tasks.value.push({ ...currentTask, id: newId });
            }
            
            saveToLocalStorage();
            resetForm();
            updateChart();
          };

          // ç¼–è¾‘ä»»åŠ¡
          const editTask = (task) => {
            Object.assign(currentTask, task);
            editingTask.value = { ...task };
            showAddModal.value = true;
          };

          // å‡†å¤‡åˆ é™¤ä»»åŠ¡ï¼ˆæ˜¾ç¤ºç¡®è®¤æ¨¡æ€æ¡†ï¼‰
          const prepareDeleteTask = (task) => {
            taskToDelete.value = task;
            showDeleteModal.value = true;
          };

          // ç¡®è®¤åˆ é™¤ä»»åŠ¡
          const confirmDelete = () => {
            if (taskToDelete.value) {
              tasks.value = tasks.value.filter(task => task.id !== taskToDelete.value.id);
              saveToLocalStorage();
              updateChart();
            }
            showDeleteModal.value = false;
            taskToDelete.value = null;
          };

          // å–æ¶ˆåˆ é™¤
          const cancelDelete = () => {
            showDeleteModal.value = false;
            taskToDelete.value = null;
          };

          // å–æ¶ˆç¼–è¾‘
          const cancelEdit = () => {
            showAddModal.value = false;
            resetForm();
          };

          // é‡ç½®è¡¨å•
          const resetForm = () => {
            currentTask.title = '';
            currentTask.startDate = '';
            currentTask.endDate = '';
            currentTask.progress = 0;
            editingTask.value = null;
          };

          // æ ¼å¼åŒ–æ—¥æœŸæ˜¾ç¤º
          const formatDate = (dateString) => {
            return new Date(dateString).toLocaleDateString('zh-CN', {
              year: 'numeric',
              month: '2-digit',
              day: '2-digit',
              hour: '2-digit',
              minute: '2-digit'
            });
          };

          // åˆ›å»ºæ‚¬åœæ•ˆæœå’Œæ‹–æ‹½æ‰‹æŸ„å…ƒç´ 
          const createOverlayElements = () => {
            // åˆ›å»ºæ‚¬åœè¦†ç›–å±‚
            hoverOverlay = document.createElement('div');
            hoverOverlay.style.position = 'absolute';
            hoverOverlay.style.border = '2px solid white';
            hoverOverlay.style.boxShadow = '0 0 0 2px rgba(255,255,255,0.5)';
            hoverOverlay.style.pointerEvents = 'none';
            hoverOverlay.style.zIndex = '5';
            hoverOverlay.style.display = 'none';
            hoverOverlay.style.borderRadius = '4px';
            
            // åˆ›å»ºå·¦æ‹–æ‹½æ‰‹æŸ„
            leftHandle = document.createElement('div');
            leftHandle.className = 'drag-handle-left';
            leftHandle.style.position = 'absolute';
            leftHandle.style.width = '8px';
            leftHandle.style.height = '100%';
            leftHandle.style.top = '0';
            leftHandle.style.cursor = 'ew-resize';
            leftHandle.style.pointerEvents = 'auto';
            leftHandle.style.display = 'none';
            leftHandle.style.zIndex = '10';
            leftHandle.style.borderRadius = '2px';
            
            // åˆ›å»ºå³æ‹–æ‹½æ‰‹æŸ„
            rightHandle = document.createElement('div');
            rightHandle.className = 'drag-handle-right';
            rightHandle.style.position = 'absolute';
            rightHandle.style.width = '8px';
            rightHandle.style.height = '100%';
            rightHandle.style.top = '0';
            rightHandle.style.cursor = 'ew-resize';
            rightHandle.style.pointerEvents = 'auto';
            rightHandle.style.display = 'none';
            rightHandle.style.zIndex = '10';
            rightHandle.style.borderRadius = '2px';
            
            // æ·»åŠ åˆ°å›¾è¡¨å®¹å™¨
            if (ganttChart.value) {
              ganttChart.value.appendChild(hoverOverlay);
              ganttChart.value.appendChild(leftHandle);
              ganttChart.value.appendChild(rightHandle);
            }
          };

          // æ›´æ–°å›¾è¡¨
          const updateChart = () => {
            if (isUpdating) return; // é˜²æ­¢å¹¶å‘æ›´æ–°
            isUpdating = true;
            
            if (chartInstance) {
              chartInstance.destroy();
            }
            
            if (tasks.value.length === 0) {
              isUpdating = false;
              return;
            }
            
            // å‡†å¤‡å›¾è¡¨æ•°æ®
            const chartData = tasks.value.map(task => ({
              x: [new Date(task.startDate), new Date(task.endDate)],
              y: task.title,
              progress: task.progress,
              id: task.id
            }));
            
            // åˆ›å»ºç”˜ç‰¹å›¾
            const ctx = document.createElement('canvas');
            if (ganttChart.value) {
              // æ¸…ç©ºå®¹å™¨ä½†ä¿ç•™è¦†ç›–å±‚å…ƒç´ 
              const children = Array.from(ganttChart.value.children);
              children.forEach(child => {
                if (child !== hoverOverlay && child !== leftHandle && child !== rightHandle) {
                  ganttChart.value.removeChild(child);
                }
              });
              
              ganttChart.value.appendChild(ctx);
              
              chartInstance = new Chart(ctx, {
                type: 'bar',
                data: {
                  labels: tasks.value.map(task => task.title),
                  datasets: [{
                    label: 'ä»»åŠ¡æ—¶é—´çº¿',
                    data: chartData,
                    backgroundColor: function(context) {
                      const progress = context.dataset.data[context.dataIndex].progress;
                      // æ ¹æ®è¿›åº¦è¿”å›ä¸åŒé¢œè‰²
                      if (progress >= 80) return 'rgba(40, 167, 69, 0.7)'; // ç»¿è‰² - å®Œæˆåº¦é«˜
                      if (progress >= 50) return 'rgba(0, 123, 255, 0.7)'; // è“è‰² - è¿›è¡Œä¸­
                      if (progress > 0) return 'rgba(255, 193, 7, 0.7)';  // é»„è‰² - åˆšå¼€å§‹
                      return 'rgba(220, 53, 69, 0.7)'; // çº¢è‰² - æœªå¼€å§‹
                    },
                    borderColor: function(context) {
                      const progress = context.dataset.data[context.dataIndex].progress;
                      if (progress >= 80) return 'rgb(40, 167, 69)';
                      if (progress >= 50) return 'rgb(0, 123, 255)';
                      if (progress > 0) return 'rgb(255, 193, 7)';
                      return 'rgb(220, 53, 69)';
                    },
                    borderWidth: 1,
                    borderSkipped: false,
                    borderRadius: 5,
                    // å›ºå®šæ¡å½¢é«˜åº¦
                    barPercentage: 0.6,
                    categoryPercentage: 0.8,
                    // æ˜¾ç¤ºè¿›åº¦æ¡è¦†ç›–åœ¨ä»»åŠ¡æ¡ä¸Š
                    datalabels: {
                      align: 'center',
                      anchor: 'center',
                      formatter: function(value, context) {
                        const progress = context.dataset.data[context.dataIndex].progress;
                        return progress + '%';
                      },
                      color: '#fff',
                      font: {
                        weight: 'bold'
                      }
                    }
                  }]
                },
                options: {
                  indexAxis: 'y',
                  responsive: true,
                  maintainAspectRatio: false,
                  scales: {
                    x: {
                      type: 'time',
                      time: {
                        unit: viewRange.value === 'week' ? 'day' : 
                             viewRange.value === 'month' ? 'day' : 'week',
                        tooltipFormat: 'yyyy-MM-dd HH:mm'
                      },
                      min: new Date(Date.now() - (viewRange.value === 'week' ? 7 : viewRange.value === 'month' ? 30 : 90) * 24 * 60 * 60 * 1000),
                      max: new Date(Date.now() + (viewRange.value === 'week' ? 14 : viewRange.value === 'month' ? 30 : 90) * 24 * 60 * 60 * 1000),
                      title: {
                        display: true,
                        text: 'æ—¶é—´è½´'
                      }
                    },
                    y: {
                      title: {
                        display: true,
                        text: 'ä»»åŠ¡'
                      },
                      // ç¡®ä¿ä»»åŠ¡æ¡å‚ç›´å±…ä¸­
                      offset: true,
                      ticks: {
                        font: {
                          size: 14
                        }
                      },
                      grid: {
                        display: true,
                        color: 'rgba(0, 0, 0, 0.1)'
                      }
                    }
                  },
                  plugins: {
                    legend: {
                      display: false
                    },
                    tooltip: {
                      callbacks: {
                        label: function(context) {
                          const task = tasks.value[context.dataIndex];
                          return [
                            `ä»»åŠ¡: ${task.title}`,
                            `å¼€å§‹: ${formatDate(task.startDate)}`,
                            `ç»“æŸ: ${formatDate(task.endDate)}`,
                            `è¿›åº¦: ${task.progress}%`
                          ];
                        }
                      }
                    }
                  },
                  animation: {
                    duration: 300
                  },
                  // å¯ç”¨æ‹–æ‹½åŠŸèƒ½
                  onClick: (event, elements) => {
                    // ä¸åœ¨è¿™é‡Œå¤„ç†ç‚¹å‡»äº‹ä»¶ï¼Œæ”¹ä¸ºåœ¨canvasäº‹ä»¶ç›‘å¬å™¨ä¸­å¤„ç†
                  }
                }
              });
              
              // æ·»åŠ æ‹–æ‹½è°ƒæ•´æ—¶é—´èŒƒå›´çš„åŠŸèƒ½
              setupDragFunctionality(ctx, chartInstance);
            }
            
            isUpdating = false;
          };

          // æ‹–æ‹½åŠŸèƒ½å®ç°
          const setupDragFunctionality = (canvas, chart) => {
            let isDragging = false;
            let dragStartX = 0;
            let originalStartDate, originalEndDate;
            let taskIndex = -1;
            let dragType = ''; // 'left', 'right', or 'move'

            // è·å–é¼ æ ‡ä½ç½®
            const getMousePos = (canvas, evt) => {
              const rect = canvas.getBoundingClientRect();
              return {
                x: evt.clientX - rect.left,
                y: evt.clientY - rect.top
              };
            };

            // è·å–ä»»åŠ¡æ¡è¾¹ç•Œä¿¡æ¯ - ä½¿ç”¨æ›´ç²¾ç¡®çš„æ–¹æ³•
            const getTaskBounds = () => {
              const bounds = [];
              
              // éå†æ‰€æœ‰ä»»åŠ¡ï¼Œæ ¹æ®å›¾è¡¨çš„xè½´æ—¶é—´èŒƒå›´è®¡ç®—æ¯ä¸ªä»»åŠ¡åœ¨ç”»å¸ƒä¸Šçš„å®é™…ä½ç½®
              const timeScale = chart.scales.x;
              const yScale = chart.scales.y;
              
              for (let i = 0; i < tasks.value.length; i++) {
                const task = tasks.value[i];
                
                // å°†æ—¥æœŸè½¬æ¢ä¸ºåƒç´ åæ ‡
                const startX = timeScale.getPixelForValue(new Date(task.startDate));
                const endX = timeScale.getPixelForValue(new Date(task.endDate));
                
                // è·å–Yè½´åæ ‡
                const yValue = task.title; // ä½¿ç”¨ä»»åŠ¡æ ‡é¢˜ä½œä¸ºYè½´å€¼
                const y = yScale.getPixelForValue(yValue);
                
                // è®¡ç®—æ¡å½¢å›¾çš„é«˜åº¦å’Œä½ç½®
                const barHeight = chart.options.scales.y.ticks.fontSize || 12;
                const height = barHeight * 3; // å¢åŠ é«˜åº¦ä»¥ä¾¿äºç‚¹å‡»
                const top = y - height/2;
                const bottom = y + height/2;
                
                bounds.push({
                  index: i,
                  left: startX,
                  right: endX,
                  top: top,
                  bottom: bottom,
                  center: y,
                  width: endX - startX,
                  height: height
                });
              }
              
              return bounds;
            };

            // æŸ¥æ‰¾é¼ æ ‡ä½ç½®å¯¹åº”çš„ä»»åŠ¡åŠè¾¹ç¼˜
            const findTaskAtPosition = (mouseX, mouseY) => {
              const bounds = getTaskBounds();
              
              for (let i = 0; i < bounds.length; i++) {
                const bound = bounds[i];
                
                // æ£€æŸ¥é¼ æ ‡æ˜¯å¦åœ¨ä»»åŠ¡æ¡å‚ç›´èŒƒå›´å†…
                if (mouseY >= bound.top && mouseY <= bound.bottom) {
                  // æ£€æŸ¥æ˜¯å¦åœ¨ä»»åŠ¡æ¡æ°´å¹³èŒƒå›´å†…
                  if (mouseX >= bound.left && mouseX <= bound.right) {
                    // æ£€æŸ¥æ˜¯å¦åœ¨å·¦è¾¹ç¼˜ï¼ˆ20åƒç´ èŒƒå›´å†…ï¼‰
                    if (Math.abs(mouseX - bound.left) <= 20) {
                      return { index: i, side: 'left' };
                    }
                    // æ£€æŸ¥æ˜¯å¦åœ¨å³è¾¹ç¼˜ï¼ˆ20åƒç´ èŒƒå›´å†…ï¼‰
                    else if (Math.abs(mouseX - bound.right) <= 20) {
                      return { index: i, side: 'right' };
                    }
                    // åœ¨ä¸­é—´åŒºåŸŸ
                    else {
                      return { index: i, side: 'middle' };
                    }
                  }
                }
              }
              return null;
            };
            
            // å¤„ç†Canvasç‚¹å‡»äº‹ä»¶ï¼ˆç¼–è¾‘ä»»åŠ¡ï¼‰
            const handleCanvasClick = (event) => {
              const mousePos = getMousePos(canvas, event);
              const taskInfo = findTaskAtPosition(mousePos.x, mousePos.y);
              
              if (taskInfo && taskInfo.side === 'middle') { // åªæœ‰åœ¨ä¸­é—´åŒºåŸŸç‚¹å‡»æ‰è§¦å‘ç¼–è¾‘
                const clickedTask = tasks.value[taskInfo.index];
                if (clickedTask) {
                  editTask(clickedTask);
                }
              }
            };

            // å­˜å‚¨ä¸Šä¸€ä¸ªä»»åŠ¡ä¿¡æ¯ï¼Œç”¨äºæ¯”è¾ƒæ˜¯å¦éœ€è¦æ›´æ–°
            let prevTaskInfo = null;
            
            // æ›´æ–°æ‚¬åœæ•ˆæœ
            const updateHoverEffect = (mouseX, mouseY) => {
              const taskInfo = findTaskAtPosition(mouseX, mouseY);
              
              // åªæœ‰å½“ä»»åŠ¡å‘ç”Ÿå˜åŒ–æ—¶æ‰æ›´æ–°ï¼Œé¿å…é¢‘ç¹æ›´æ–°é€ æˆé—ªçƒ
              if (JSON.stringify(taskInfo) !== JSON.stringify(prevTaskInfo)) {
                prevTaskInfo = taskInfo ? {...taskInfo} : null;
                
                if (taskInfo) {
                  const bounds = getTaskBounds();
                  const bound = bounds[taskInfo.index];
                  
                  // è®¾ç½®æ‚¬åœè¦†ç›–å±‚çš„ä½ç½®å’Œå¤§å°
                  if (hoverOverlay) {
                    hoverOverlay.style.left = bound.left + 'px';
                    hoverOverlay.style.top = bound.top + 'px';
                    hoverOverlay.style.width = bound.width + 'px';
                    hoverOverlay.style.height = bound.height + 'px';
                    hoverOverlay.style.display = 'block';
                    
                    // æ ¹æ®ä»»åŠ¡è¿›åº¦è®¾ç½®è¾¹æ¡†é¢œè‰²
                    const task = tasks.value[taskInfo.index];
                    const progress = task.progress;
                    if (progress >= 80) {
                      hoverOverlay.style.borderColor = 'rgb(40, 167, 69)';
                      hoverOverlay.style.boxShadow = '0 0 0 2px rgba(40, 167, 69, 0.5)';
                    } else if (progress >= 50) {
                      hoverOverlay.style.borderColor = 'rgb(0, 123, 255)';
                      hoverOverlay.style.boxShadow = '0 0 0 2px rgba(0, 123, 255, 0.5)';
                    } else if (progress > 0) {
                      hoverOverlay.style.borderColor = 'rgb(255, 193, 7)';
                      hoverOverlay.style.boxShadow = '0 0 0 2px rgba(255, 193, 7, 0.5)';
                    } else {
                      hoverOverlay.style.borderColor = 'white';
                      hoverOverlay.style.boxShadow = '0 0 0 2px rgba(255,255,255,0.5)';
                    }
                  }
                  
                  // è®¾ç½®æ‹–æ‹½æ‰‹æŸ„çš„ä½ç½®
                  if (leftHandle && rightHandle) {
                    leftHandle.style.left = bound.left + 'px';
                    leftHandle.style.top = bound.top + 'px';
                    leftHandle.style.height = bound.height + 'px';
                    leftHandle.style.display = 'block';
                    
                    rightHandle.style.left = (bound.right - 8) + 'px';
                    rightHandle.style.top = bound.top + 'px';
                    rightHandle.style.height = bound.height + 'px';
                    rightHandle.style.display = 'block';
                    
                    // æ ¹æ®ä»»åŠ¡è¿›åº¦è®¾ç½®æ‰‹æŸ„é¢œè‰²
                    const task = tasks.value[taskInfo.index];
                    const progress = task.progress;
                    if (progress >= 80) {
                      leftHandle.style.background = 'repeating-linear-gradient(45deg, transparent, transparent 4px, rgba(40, 167, 69, 0.8) 4px, rgba(40, 167, 69, 0.8) 6px)';
                      rightHandle.style.background = 'repeating-linear-gradient(45deg, transparent, transparent 4px, rgba(40, 167, 69, 0.8) 4px, rgba(40, 167, 69, 0.8) 6px)';
                    } else if (progress >= 50) {
                      leftHandle.style.background = 'repeating-linear-gradient(45deg, transparent, transparent 4px, rgba(0, 123, 255, 0.8) 4px, rgba(0, 123, 255, 0.8) 6px)';
                      rightHandle.style.background = 'repeating-linear-gradient(45deg, transparent, transparent 4px, rgba(0, 123, 255, 0.8) 4px, rgba(0, 123, 255, 0.8) 6px)';
                    } else if (progress > 0) {
                      leftHandle.style.background = 'repeating-linear-gradient(45deg, transparent, transparent 4px, rgba(255, 193, 7, 0.8) 4px, rgba(255, 193, 7, 0.8) 6px)';
                      rightHandle.style.background = 'repeating-linear-gradient(45deg, transparent, transparent 4px, rgba(255, 193, 7, 0.8) 4px, rgba(255, 193, 7, 0.8) 6px)';
                    } else {
                      leftHandle.style.background = 'repeating-linear-gradient(45deg, transparent, transparent 4px, rgba(255, 255, 255, 0.8) 4px, rgba(255, 255, 255, 0.8) 6px)';
                      rightHandle.style.background = 'repeating-linear-gradient(45deg, transparent, transparent 4px, rgba(255, 255, 255, 0.8) 4px, rgba(255, 255, 255, 0.8) 6px)';
                    }
                  }
                  
                  canvas.style.cursor = taskInfo.side === 'left' || taskInfo.side === 'right' ? 'ew-resize' : 'pointer';
                } else {
                  // éšè—æ‚¬åœæ•ˆæœ
                  if (hoverOverlay) hoverOverlay.style.display = 'none';
                  if (leftHandle) leftHandle.style.display = 'none';
                  if (rightHandle) rightHandle.style.display = 'none';
                  canvas.style.cursor = 'default';
                }
              }
            };

            // é¼ æ ‡æŒ‰ä¸‹äº‹ä»¶
            canvas.addEventListener('mousedown', (e) => {
              const mousePos = getMousePos(canvas, e);
              const taskInfo = findTaskAtPosition(mousePos.x, mousePos.y);
              
              if (taskInfo) {
                isDragging = true;
                dragStartX = mousePos.x;
                taskIndex = taskInfo.index;
                dragType = taskInfo.side;
                
                const task = tasks.value[taskIndex];
                originalStartDate = new Date(task.startDate);
                originalEndDate = new Date(task.endDate);
                
                // æ”¹å˜é¼ æ ‡æŒ‡é’ˆ
                canvas.style.cursor = dragType === 'left' || dragType === 'right' ? 'ew-resize' : 'grabbing';
              }
            });

            let dragAnimationFrame = null;
            
            // é¼ æ ‡ç§»åŠ¨äº‹ä»¶
            canvas.addEventListener('mousemove', (e) => {
              const mousePos = getMousePos(canvas, e);
              
              if (!isDragging) {
                updateHoverEffect(mousePos.x, mousePos.y);
                return;
              }

              // åœ¨æ‹–æ‹½è¿‡ç¨‹ä¸­ï¼Œä½¿ç”¨requestAnimationFrameæ¥ä¼˜åŒ–æ›´æ–°é¢‘ç‡
              if (dragAnimationFrame) {
                cancelAnimationFrame(dragAnimationFrame);
              }
              
              dragAnimationFrame = requestAnimationFrame(() => {
                const deltaX = mousePos.x - dragStartX;

                // æ ¹æ®å›¾è¡¨æ¯”ä¾‹è®¡ç®—æ—¶é—´å˜åŒ–
                const timeScale = chart.scales.x;
                const chartArea = chart.chartArea;
                
                // è·å–æ—¶é—´èŒƒå›´å¯¹åº”çš„åƒç´ èŒƒå›´
                const startDate = new Date(timeScale.min);
                const endDate = new Date(timeScale.max);
                const totalTimeRange = endDate - startDate;
                const pixelRange = chartArea.right - chartArea.left;
                const msPerPixel = totalTimeRange / pixelRange;

                // è®¡ç®—æ—¶é—´å˜åŒ–é‡
                const timeChange = Math.round(deltaX * msPerPixel);

                // æ ¹æ®æ‹–æ‹½ç±»å‹æ›´æ–°ä»»åŠ¡æ—¶é—´
                let newStartDate = originalStartDate;
                let newEndDate = originalEndDate;
                
                if (dragType === 'left') {
                  // è°ƒæ•´å¼€å§‹æ—¶é—´ï¼Œç»“æŸæ—¶é—´ä¿æŒä¸å˜
                  newStartDate = new Date(originalStartDate.getTime() + timeChange);
                  // ç¡®ä¿å¼€å§‹æ—¶é—´ä¸æ™šäºç»“æŸæ—¶é—´
                  if (newStartDate < originalEndDate) {
                    tasks.value[taskIndex].startDate = newStartDate.toISOString().slice(0, 16);
                  } else {
                    // å¦‚æœå¼€å§‹æ—¶é—´æ™šäºç»“æŸæ—¶é—´ï¼Œåˆ™æ¢å¤åŸå€¼
                    newStartDate = originalStartDate;
                  }
                } else if (dragType === 'right') {
                  // è°ƒæ•´ç»“æŸæ—¶é—´ï¼Œå¼€å§‹æ—¶é—´ä¿æŒä¸å˜
                  newEndDate = new Date(originalEndDate.getTime() + timeChange);
                  // ç¡®ä¿ç»“æŸæ—¶é—´ä¸æ—©äºå¼€å§‹æ—¶é—´
                  if (newEndDate > originalStartDate) {
                    tasks.value[taskIndex].endDate = newEndDate.toISOString().slice(0, 16);
                  } else {
                    // å¦‚æœç»“æŸæ—¶é—´æ—©äºå¼€å§‹æ—¶é—´ï¼Œåˆ™æ¢å¤åŸå€¼
                    newEndDate = originalEndDate;
                  }
                } else if (dragType === 'middle') {
                  // ç§»åŠ¨æ•´ä¸ªä»»åŠ¡
                  newStartDate = new Date(originalStartDate.getTime() + timeChange);
                  newEndDate = new Date(originalEndDate.getTime() + timeChange);
                  tasks.value[taskIndex].startDate = newStartDate.toISOString().slice(0, 16);
                  tasks.value[taskIndex].endDate = newEndDate.toISOString().slice(0, 16);
                }

                // åœ¨æ‹–æ‹½è¿‡ç¨‹ä¸­åªæ›´æ–°å›¾è¡¨ä¸­çš„æ•°æ®ç‚¹ï¼Œè€Œä¸æ˜¯é‡æ–°åˆ›å»ºæ•´ä¸ªå›¾è¡¨
                if (chart.data.datasets && chart.data.datasets[0] && chart.data.datasets[0].data[taskIndex]) {
                  // æ›´æ–°å›¾è¡¨ä¸­çš„æ•°æ®ç‚¹
                  chart.data.datasets[0].data[taskIndex].x = [new Date(tasks.value[taskIndex].startDate), new Date(tasks.value[taskIndex].endDate)];
                  chart.update('none'); // ä½¿ç”¨æ— åŠ¨ç”»æ›´æ–°ï¼Œé¿å…é—ªçƒ
                  
                  // åœ¨æ‹–æ‹½æœŸé—´å¼ºåˆ¶æ›´æ–°æ‚¬åœæ•ˆæœï¼Œå³ä½¿ä»»åŠ¡æ²¡å˜ä¹Ÿè¦æ›´æ–°ä½ç½®
                  prevTaskInfo = null; // æ¸…é™¤ç¼“å­˜å¼ºåˆ¶æ›´æ–°
                  updateHoverEffect(mousePos.x, mousePos.y);
                }
              });
            });

            // é¼ æ ‡é‡Šæ”¾äº‹ä»¶
            canvas.addEventListener('mouseup', () => {
              if (isDragging) {
                isDragging = false;
                taskIndex = -1;
                dragType = '';
                canvas.style.cursor = 'default';
                
                // å–æ¶ˆæ‹–æ‹½åŠ¨ç”»å¸§
                if (dragAnimationFrame) {
                  cancelAnimationFrame(dragAnimationFrame);
                  dragAnimationFrame = null;
                }
                
                // åœ¨æ‹–æ‹½ç»“æŸåæ‰ä¿å­˜æ•°æ®åˆ°æœ¬åœ°å­˜å‚¨
                saveToLocalStorage();
              }
            });

            // å¤„ç†Canvasç‚¹å‡»äº‹ä»¶ï¼ˆç¼–è¾‘ä»»åŠ¡ï¼‰
            canvas.addEventListener('click', handleCanvasClick);

            // é¼ æ ‡ç¦»å¼€ç”»å¸ƒäº‹ä»¶
            canvas.addEventListener('mouseleave', () => {
              if (isDragging) {
                isDragging = false;
                taskIndex = -1;
                dragType = '';
                canvas.style.cursor = 'default';
                
                // å–æ¶ˆæ‹–æ‹½åŠ¨ç”»å¸§
                if (dragAnimationFrame) {
                  cancelAnimationFrame(dragAnimationFrame);
                  dragAnimationFrame = null;
                }
                
                // åœ¨æ‹–æ‹½ç»“æŸåæ‰ä¿å­˜æ•°æ®åˆ°æœ¬åœ°å­˜å‚¨
                saveToLocalStorage();
              }
              
              // éšè—æ‚¬åœæ•ˆæœ
              if (hoverOverlay) hoverOverlay.style.display = 'none';
              if (leftHandle) leftHandle.style.display = 'none';
              if (rightHandle) rightHandle.style.display = 'none';
            });
          };

          // ç›‘å¬è§†å›¾èŒƒå›´å˜åŒ–
          watch(viewRange, () => {
            updateChart();
          });

          // é¡µé¢åŠ è½½æ—¶åˆå§‹åŒ–å›¾è¡¨
          onMounted(() => {
            createOverlayElements();
            updateChart();
          });

          // ç»„ä»¶å¸è½½æ—¶é”€æ¯å›¾è¡¨
          onUnmounted(() => {
            if (chartInstance) {
              chartInstance.destroy();
            }
            
            // ç§»é™¤è¦†ç›–å±‚å…ƒç´ 
            if (hoverOverlay && hoverOverlay.parentNode) {
              hoverOverlay.parentNode.removeChild(hoverOverlay);
            }
            if (leftHandle && leftHandle.parentNode) {
              leftHandle.parentNode.removeChild(leftHandle);
            }
            if (rightHandle && rightHandle.parentNode) {
              rightHandle.parentNode.removeChild(rightHandle);
            }
          });

          return {
            tasks,
            showAddModal,
            showDeleteModal,
            editingTask,
            taskToDelete,
            viewRange,
            ganttChart,
            currentTask,
            saveTask,
            editTask,
            prepareDeleteTask,
            confirmDelete,
            cancelDelete,
            cancelEdit,
            formatDate,
            updateChart
          };
        }
      }).mount('#app');
    });
  </script>
</body>
</html>