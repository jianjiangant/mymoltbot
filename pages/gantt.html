<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>ç”˜ç‰¹å›¾ - MyMoltBot</title>
  <script src="https://unpkg.com/vue@3/dist/vue.global.js"></script>
  <link rel="stylesheet" href="../src/styles/gantt.css">
</head>
<body>
  <div id="app" v-cloak>
    <div class="container">
      <div class="header">
        <h1>ğŸ“Š ç”˜ç‰¹å›¾</h1>
        <p>å¯è§†åŒ–ç®¡ç†å¾…åŠäº‹é¡¹æ—¶é—´å…³ç³»</p>
        <a href="../index.html" class="back-link">â† è¿”å›ä¸»é¡µ</a>
      </div>
      
      <div class="gantt-content">
        <div class="controls">
          <button @click="showAddModal = true" class="add-task-btn">â• æ·»åŠ ä»»åŠ¡</button>
          <div class="view-controls">
            <label>è§†å›¾èŒƒå›´ï¼š</label>
            <select v-model="viewRange" @change="updateGantt" class="range-select">
              <option value="week">æœ¬å‘¨</option>
              <option value="month">æœ¬æœˆ</option>
              <option value="quarter">å­£åº¦</option>
            </select>
          </div>
        </div>
        
        <div class="gantt-container">
          <!-- æ—¶é—´è½´å¤´éƒ¨ -->
          <div class="gantt-header">
            <div class="task-name-column">ä»»åŠ¡åç§°</div>
            <div class="timeline-header" ref="timelineHeader">
              <template v-for="timeSlot in timeSlots" :key="timeSlot.label">
                <div class="time-slot">{{ timeSlot.label }}</div>
              </template>
            </div>
          </div>
          
          <!-- ç”˜ç‰¹å›¾ä¸»ä½“ -->
          <div class="gantt-body" ref="ganttBody" @scroll="onScroll">
            <div class="task-rows">
              <template v-for="(task, index) in tasks" :key="task.id">
                <div class="gantt-row">
                  <div class="task-name">{{ task.title }}</div>
                  <div class="gantt-chart-area" 
                       :ref="'chartArea' + index"
                       @mousemove="handleMouseMove"
                       @mouseup="endDrag"
                       @mouseleave="endDrag">
                    <!-- ä»»åŠ¡æ¡ -->
                    <div class="gantt-bar"
                         :style="getTaskStyle(task)"
                         :data-task-id="task.id"
                         @mouseenter="showTaskInfo($event, task)"
                         @mouseleave="hideTaskInfo"
                         @mousedown.left="startBarDrag($event, task, 'move')">
                      <!-- å·¦ä¾§æ‹–æ‹½æ‰‹æŸ„ -->
                      <div class="gantt-bar-handle-left"
                           @mousedown.left.stop="startBarDrag($event, task, 'resize-left')"
                           :style="{ backgroundColor: getProgressColor(task.progress) }">
                      </div>
                      
                      <!-- ä»»åŠ¡è¿›åº¦æ–‡æœ¬ -->
                      <div class="gantt-bar-label">{{ task.title }} ({{ task.progress }}%)</div>
                      
                      <!-- å³ä¾§æ‹–æ‹½æ‰‹æŸ„ -->
                      <div class="gantt-bar-handle-right"
                           @mousedown.left.stop="startBarDrag($event, task, 'resize-right')"
                           :style="{ backgroundColor: getProgressColor(task.progress) }">
                      </div>
                    </div>
                    
                    <!-- æ‚¬åœè¦†ç›–å±‚ -->
                    <div v-show="hoveredTaskId === task.id"
                         class="gantt-hover-overlay"
                         :style="getTaskStyle(task)">
                    </div>
                  </div>
                </div>
              </template>
            </div>
          </div>
          
          <!-- ä»»åŠ¡ä¿¡æ¯æç¤ºæ¡† -->
          <div v-show="showTaskTooltip"
               class="task-tooltip"
               :style="{ top: tooltipTop + 'px', left: tooltipLeft + 'px' }">
            <div><strong>{{ hoveredTask?.title }}</strong></div>
            <div>å¼€å§‹: {{ formatDate(hoveredTask?.startDate) }}</div>
            <div>ç»“æŸ: {{ formatDate(hoveredTask?.endDate) }}</div>
            <div>è¿›åº¦: {{ hoveredTask?.progress }}%</div>
          </div>
        </div>
        
        <div class="tasks-list">
          <h3>ä»»åŠ¡åˆ—è¡¨</h3>
          <div class="task-item" v-for="task in tasks" :key="task.id">
            <div class="task-info">
              <strong>{{ task.title }}</strong>
              <div class="task-dates">{{ formatDate(task.startDate) }} - {{ formatDate(task.endDate) }}</div>
              <div class="task-progress">è¿›åº¦: {{ task.progress }}%</div>
            </div>
            <div class="task-actions">
              <button @click="editTask(task)" class="edit-btn">ç¼–è¾‘</button>
              <button @click="prepareDeleteTask(task)" class="delete-btn">åˆ é™¤</button>
            </div>
          </div>
        </div>
      </div>
      
      <!-- æ·»åŠ /ç¼–è¾‘ä»»åŠ¡æ¨¡æ€æ¡† -->
      <div v-if="showAddModal" class="modal-overlay" @click="showAddModal = false">
        <div class="modal-content" @click.stop>
          <h3>{{ editingTask ? 'ç¼–è¾‘ä»»åŠ¡' : 'æ·»åŠ ä»»åŠ¡' }}</h3>
          <form @submit.prevent="saveTask">
            <div class="form-group">
              <label>ä»»åŠ¡åç§°:</label>
              <input 
                v-model="currentTask.title" 
                type="text" 
                class="form-input" 
                required
              />
            </div>
            <div class="form-row">
              <div class="form-group">
                <label>å¼€å§‹æ—¥æœŸ:</label>
                <input 
                  v-model="currentTask.startDate" 
                  type="datetime-local" 
                  class="form-input" 
                  required
                />
              </div>
              <div class="form-group">
                <label>ç»“æŸæ—¥æœŸ:</label>
                <input 
                  v-model="currentTask.endDate" 
                  type="datetime-local" 
                  class="form-input" 
                  required
                />
              </div>
            </div>
            <div class="form-group">
              <label>è¿›åº¦ (%):</label>
              <input 
                v-model.number="currentTask.progress" 
                type="range" 
                min="0" 
                max="100" 
                class="progress-slider"
              />
              <span class="progress-value">{{ currentTask.progress }}%</span>
            </div>
            <div class="form-actions">
              <button type="submit" class="save-btn">ä¿å­˜</button>
              <button type="button" @click="cancelEdit" class="cancel-btn">å–æ¶ˆ</button>
            </div>
          </form>
        </div>
      </div>
      
      <!-- åˆ é™¤ç¡®è®¤æ¨¡æ€æ¡† -->
      <div v-if="showDeleteModal" class="modal-overlay" @click="showDeleteModal = false">
        <div class="modal-content" @click.stop>
          <h3>ç¡®è®¤åˆ é™¤</h3>
          <p>æ‚¨ç¡®å®šè¦åˆ é™¤ä»»åŠ¡ "{{ taskToDelete?.title }}" å—ï¼Ÿæ­¤æ“ä½œæ— æ³•æ’¤é”€ã€‚</p>
          <div class="form-actions">
            <button @click="confirmDelete" class="save-btn danger">åˆ é™¤</button>
            <button @click="cancelDelete" class="cancel-btn">å–æ¶ˆ</button>
          </div>
        </div>
      </div>
    </div>
  </div>

  <script>
    // ç¡®ä¿åœ¨DOMå®Œå…¨åŠ è½½åæ‰æ‰§è¡Œ
    if (document.readyState === 'loading') {
      document.addEventListener('DOMContentLoaded', initApp);
    } else {
      // DOMå·²ç»åŠ è½½å®Œæˆ
      initApp();
    }
    
    function initApp() {
      // æ£€æŸ¥Vueæ˜¯å¦å¯ç”¨
      if (typeof Vue === 'undefined') {
        console.error('Vue is not loaded');
        return;
      }
      
      const { createApp, ref, reactive, computed, onMounted } = Vue;
      
      // ä»localStorageåŠ è½½ä»»åŠ¡æ•°æ®ï¼Œå¦‚æœä¸å­˜åœ¨åˆ™ä½¿ç”¨é»˜è®¤æ•°æ®
      const savedTasks = localStorage.getItem('ganttTasks');
      let initialTasks = [];
      
      if (savedTasks && savedTasks !== 'undefined' && savedTasks !== 'null') {
        try {
          initialTasks = JSON.parse(savedTasks);
        } catch (e) {
          console.error('Error parsing tasks from localStorage:', e);
          // å¦‚æœè§£æå¤±è´¥ï¼Œä½¿ç”¨é»˜è®¤ä»»åŠ¡
          initialTasks = getDefaultTasks();
        }
      } else {
        // å¦‚æœlocalStorageä¸­æ²¡æœ‰æ•°æ®ï¼Œåˆ™åˆå§‹åŒ–é»˜è®¤ä»»åŠ¡
        initialTasks = getDefaultTasks();
      }
      
      // åˆ›å»ºåº”ç”¨
      const app = createApp({
        setup() {
          // ä»»åŠ¡æ•°æ® - åœ¨setupä¸­ç›´æ¥åˆå§‹åŒ–
          const tasks = ref(initialTasks);
          const showAddModal = ref(false);
          const showDeleteModal = ref(false);
          const editingTask = ref(null);
          const taskToDelete = ref(null);
          const viewRange = ref('month');
          const hoveredTaskId = ref(null);
          const hoveredTask = ref(null);
          const showTaskTooltip = ref(false);
          const tooltipTop = ref(0);
          const tooltipLeft = ref(0);
          const timelineHeader = ref(null);
          const ganttBody = ref(null);
          
          // æ‹–æ‹½ç›¸å…³å˜é‡
          const isDragging = ref(false);
          const dragType = ref(null); // 'move', 'resize-left', 'resize-right'
          let startX, startTime, originalStart, originalEnd;
          const draggingTaskId = ref(null);
          let animationFrameId = null;
          
          // å½“å‰ä»»åŠ¡å¯¹è±¡ï¼ˆç”¨äºè¡¨å•ï¼‰
          const currentTask = reactive({
            title: '',
            startDate: '',
            endDate: '',
            progress: 0
          });
          
          // æ—¶é—´æ§½è®¡ç®—
          const timeSlots = computed(() => {
            const slots = [];
            const now = new Date();
            let startDate, endDate, interval;
            
            if (viewRange.value === 'week') {
              startDate = new Date(now);
              startDate.setDate(now.getDate() - now.getDay()); // ä»å‘¨ä¸€å¼€å§‹
              endDate = new Date(startDate);
              endDate.setDate(startDate.getDate() + 7);
              interval = 24 * 60 * 60 * 1000; // ä¸€å¤©
            } else if (viewRange.value === 'month') {
              startDate = new Date(now.getFullYear(), now.getMonth(), 1);
              endDate = new Date(now.getFullYear(), now.getMonth() + 1, 1);
              interval = 24 * 60 * 60 * 1000; // ä¸€å¤©
            } else { // quarter
              const quarter = Math.floor(now.getMonth() / 3);
              startDate = new Date(now.getFullYear(), quarter * 3, 1);
              endDate = new Date(now.getFullYear(), quarter * 3 + 3, 1);
              interval = 7 * 24 * 60 * 60 * 1000; // ä¸€å‘¨
            }
            
            for (let d = new Date(startDate); d < endDate; d.setTime(d.getTime() + interval)) {
              slots.push({
                date: new Date(d),
                label: viewRange.value === 'week' || viewRange.value === 'month' 
                  ? `${d.getMonth()+1}/${d.getDate()}` 
                  : `${d.getMonth()+1}æœˆ${d.getDate()}æ—¥`
              });
            }
            
            return slots;
          });
          
          // ç”˜ç‰¹å›¾å‚æ•°
          const pixelsPerDay = 60; // æ¯å¤©çš„åƒç´ æ•°
          
          // ä¿å­˜åˆ°æœ¬åœ°å­˜å‚¨
          const saveToLocalStorage = () => {
            localStorage.setItem('ganttTasks', JSON.stringify(tasks.value));
          };
          
          // è·å–é»˜è®¤ä»»åŠ¡
          function getDefaultTasks() {
            const now = new Date();
            const defaultTasks = [
              {
                id: 1,
                title: 'é¡¹ç›®è§„åˆ’',
                startDate: new Date(Date.now() - 3 * 24 * 60 * 60 * 1000).toISOString().slice(0, 16),
                endDate: new Date(Date.now() + 2 * 24 * 60 * 60 * 1000).toISOString().slice(0, 16),
                progress: 60
              },
              {
                id: 2,
                title: 'éœ€æ±‚åˆ†æ',
                startDate: new Date(Date.now() - 2 * 24 * 60 * 60 * 1000).toISOString().slice(0, 16),
                endDate: new Date(Date.now() + 4 * 24 * 60 * 60 * 1000).toISOString().slice(0, 16),
                progress: 30
              },
              {
                id: 3,
                title: 'å¼€å‘é˜¶æ®µ',
                startDate: new Date(Date.now()).toISOString().slice(0, 16),
                endDate: new Date(Date.now() + 7 * 24 * 60 * 60 * 1000).toISOString().slice(0, 16),
                progress: 0
              },
              {
                id: 4,
                title: 'æµ‹è¯•é˜¶æ®µ',
                startDate: new Date(Date.now() + 6 * 24 * 60 * 60 * 1000).toISOString().slice(0, 16),
                endDate: new Date(Date.now() + 10 * 24 * 60 * 60 * 1000).toISOString().slice(0, 16),
                progress: 0
              }
            ];
            localStorage.setItem('ganttTasks', JSON.stringify(defaultTasks));
            return defaultTasks;
          }
          
          // è®¡ç®—ä»»åŠ¡æ¡æ ·å¼
          const getTaskStyle = (task) => {
            // æ·»åŠ å®‰å…¨æ£€æŸ¥
            if (!task || !task.startDate || !task.endDate) {
              return {};
            }
            
            const start = new Date(task.startDate);
            const end = new Date(task.endDate);
            const startDate = getVisibleStartDate();
            const dayDiff = Math.floor((start - startDate) / (1000 * 60 * 60 * 24));
            const duration = Math.ceil((end - start) / (1000 * 60 * 60 * 24));
            
            const left = Math.max(0, dayDiff * pixelsPerDay);
            const width = Math.max(duration * pixelsPerDay, 20); // æœ€å°å®½åº¦
            
            return {
              left: left + 'px',
              width: width + 'px',
              backgroundColor: getProgressColor(task.progress),
              height: '40px',
              position: 'absolute',
              top: '5px',
              borderRadius: '4px',
              display: 'flex',
              alignItems: 'center',
              paddingLeft: '8px',
              zIndex: '10',
              cursor: 'move'
            };
          };
          
          // æ ¹æ®è¿›åº¦è·å–é¢œè‰²
          const getProgressColor = (progress) => {
            if (progress >= 80) return '#28a745'; // ç»¿è‰² - å®Œæˆåº¦é«˜
            if (progress >= 50) return '#007bff'; // è“è‰² - è¿›è¡Œä¸­
            if (progress > 0) return '#ffc107';  // é»„è‰² - åˆšå¼€å§‹
            return '#dc3545'; // çº¢è‰² - æœªå¼€å§‹
          };
          
          // è·å–å½“å‰è§†å›¾çš„èµ·å§‹æ—¥æœŸ
          const getVisibleStartDate = () => {
            const now = new Date();
            if (viewRange.value === 'week') {
              const startDate = new Date(now);
              startDate.setDate(now.getDate() - now.getDay());
              return startDate;
            } else if (viewRange.value === 'month') {
              return new Date(now.getFullYear(), now.getMonth(), 1);
            } else { // quarter
              const quarter = Math.floor(now.getMonth() / 3);
              return new Date(now.getFullYear(), quarter * 3, 1);
            }
          };
          
          // æ˜¾ç¤ºä»»åŠ¡ä¿¡æ¯
          const showTaskInfo = (event, task) => {
            // æ·»åŠ å®‰å…¨æ£€æŸ¥
            if (!task) return;
            
            hoveredTaskId.value = task.id;
            hoveredTask.value = task;
            showTaskTooltip.value = true;
            
            // å®šä½æç¤ºæ¡†
            tooltipLeft.value = event.pageX + 10;
            tooltipTop.value = event.pageY - 10;
          };
          
          // éšè—ä»»åŠ¡ä¿¡æ¯
          const hideTaskInfo = () => {
            showTaskTooltip.value = false;
            hoveredTaskId.value = null;
            hoveredTask.value = null;
          };
          
          // å¼€å§‹æ‹–æ‹½ä»»åŠ¡æ¡
          const startBarDrag = (event, task, type) => {
            // æ·»åŠ å®‰å…¨æ£€æŸ¥
            if (!task) return;
            
            event.preventDefault(); // é˜»æ­¢é»˜è®¤è¡Œä¸º
            event.stopPropagation(); // é˜²æ­¢äº‹ä»¶å†’æ³¡
            
            isDragging.value = true;
            dragType.value = type;
            draggingTaskId.value = task.id;
            
            startX = event.clientX;
            originalStart = new Date(task.startDate).getTime();
            originalEnd = new Date(task.endDate).getTime();
            
            // æ›´æ”¹é¼ æ ‡å…‰æ ‡
            if (type === 'resize-left' || type === 'resize-right') {
              document.body.style.cursor = 'ew-resize';
            } else {
              document.body.style.cursor = 'grabbing';
            }
            
            // æ·»åŠ å…¨å±€äº‹ä»¶ç›‘å¬å™¨
            document.addEventListener('mousemove', handleMouseMoveGlobal, { passive: false });
            document.addEventListener('mouseup', endDrag, { passive: false });
          };
          
          // å…¨å±€å¤„ç†é¼ æ ‡ç§»åŠ¨
          const handleMouseMoveGlobal = (event) => {
            if (!isDragging.value) return;
            
            // å–æ¶ˆä¹‹å‰çš„åŠ¨ç”»å¸§è¯·æ±‚
            if (animationFrameId) {
              cancelAnimationFrame(animationFrameId);
            }
            
            // ä½¿ç”¨requestAnimationFrameä¼˜åŒ–æ€§èƒ½
            animationFrameId = requestAnimationFrame(() => {
              const task = tasks.value.find(t => t.id === draggingTaskId.value);
              if (!task) return;
              
              const dx = event.clientX - startX;
              const daysMoved = Math.round(dx / pixelsPerDay);
              const timeOffset = daysMoved * 24 * 60 * 60 * 1000;
              
              if (dragType.value === 'resize-left') {
                // è°ƒæ•´å¼€å§‹æ—¶é—´
                const newStart = new Date(originalStart + timeOffset);
                const currentEnd = new Date(task.endDate);
                
                // ç¡®ä¿å¼€å§‹æ—¶é—´ä¸æ™šäºç»“æŸæ—¶é—´ï¼Œä¸”è‡³å°‘æœ‰ä¸€å°æ—¶çš„é—´éš”
                const minTime = new Date(currentEnd.getTime() - 60 * 60 * 1000); // è‡³å°‘1å°æ—¶
                if (newStart < currentEnd) {
                  if (newStart <= minTime) {
                    task.startDate = newStart.toISOString().slice(0, 16);
                  } else {
                    // å¦‚æœå¼€å§‹æ—¶é—´å¤ªæ¥è¿‘ç»“æŸæ—¶é—´ï¼Œç¡®ä¿è‡³å°‘æœ‰1å°æ—¶é—´éš”
                    task.startDate = minTime.toISOString().slice(0, 16);
                  }
                }
              } else if (dragType.value === 'resize-right') {
                // è°ƒæ•´ç»“æŸæ—¶é—´
                const newEnd = new Date(originalEnd + timeOffset);
                const currentStart = new Date(task.startDate);
                
                // ç¡®ä¿ç»“æŸæ—¶é—´ä¸æ—©äºå¼€å§‹æ—¶é—´ï¼Œä¸”è‡³å°‘æœ‰ä¸€å°æ—¶çš„é—´éš”
                const minTime = new Date(currentStart.getTime() + 60 * 60 * 1000); // è‡³å°‘1å°æ—¶
                if (newEnd > currentStart) {
                  if (newEnd >= minTime) {
                    task.endDate = newEnd.toISOString().slice(0, 16);
                  } else {
                    // å¦‚æœç»“æŸæ—¶é—´å¤ªæ¥è¿‘å¼€å§‹æ—¶é—´ï¼Œç¡®ä¿è‡³å°‘æœ‰1å°æ—¶é—´éš”
                    task.endDate = minTime.toISOString().slice(0, 16);
                  }
                }
              } else if (dragType.value === 'move') {
                // ç§»åŠ¨æ•´ä¸ªä»»åŠ¡
                const newStart = new Date(originalStart + timeOffset);
                const newEnd = new Date(originalEnd + timeOffset);
                
                task.startDate = newStart.toISOString().slice(0, 16);
                task.endDate = newEnd.toISOString().slice(0, 16);
              }
            });
          };
          
          // å¤„ç†é¼ æ ‡ç§»åŠ¨ï¼ˆå±€éƒ¨ï¼‰
          const handleMouseMove = (event) => {
            // ä»…ç”¨äºæ‚¬åœæ•ˆæœ
            if (!isDragging.value) {
              // æ£€æŸ¥æ˜¯å¦æ‚¬åœåœ¨ä»»åŠ¡æ¡ä¸Š
              const target = event.target.closest('[data-task-id]');
              if (target) {
                const taskId = parseInt(target.getAttribute('data-task-id'));
                const task = tasks.value.find(t => t.id === taskId);
                if (task) {
                  hoveredTaskId.value = task.id;
                  hoveredTask.value = task;
                  showTaskTooltip.value = true;
                  
                  // å®šä½æç¤ºæ¡†
                  tooltipLeft.value = event.pageX + 10;
                  tooltipTop.value = event.pageY - 10;
                }
              }
            }
          };
          
          // ç»“æŸæ‹–æ‹½
          const endDrag = () => {
            if (isDragging.value) {
              isDragging.value = false;
              draggingTaskId.value = null;
              
              // å–æ¶ˆåŠ¨ç”»å¸§
              if (animationFrameId) {
                cancelAnimationFrame(animationFrameId);
                animationFrameId = null;
              }
              
              // é‡ç½®é¼ æ ‡å…‰æ ‡
              document.body.style.cursor = 'default';
              
              // ä¿å­˜æ›´æ”¹
              saveToLocalStorage();
            }
            
            // ç§»é™¤å…¨å±€äº‹ä»¶ç›‘å¬å™¨
            document.removeEventListener('mousemove', handleMouseMoveGlobal);
            document.removeEventListener('mouseup', endDrag);
          };
          
          // æ·»åŠ æˆ–ç¼–è¾‘ä»»åŠ¡
          const saveTask = () => {
            if (!currentTask.title || !currentTask.startDate || !currentTask.endDate) {
              alert('è¯·å¡«å†™æ‰€æœ‰å¿…å¡«å­—æ®µ');
              return;
            }
            
            if (new Date(currentTask.startDate) > new Date(currentTask.endDate)) {
              alert('ç»“æŸæ—¥æœŸä¸èƒ½æ—©äºå¼€å§‹æ—¥æœŸ');
              return;
            }
            
            if (editingTask.value) {
              // ç¼–è¾‘ç°æœ‰ä»»åŠ¡
              const index = tasks.value.findIndex(t => t.id === editingTask.value.id);
              if (index !== -1) {
                // ä½¿ç”¨æ·±æ‹·è´ç¡®ä¿å“åº”æ€§
                tasks.value[index] = { ...currentTask, id: editingTask.value.id };
              }
            } else {
              // æ·»åŠ æ–°ä»»åŠ¡ - ç¡®ä¿IDæ˜¯å”¯ä¸€çš„
              const newId = tasks.value.length > 0 
                ? Math.max(...tasks.value.map(t => t.id)) + 1 
                : 1;
              tasks.value.push({ ...currentTask, id: newId });
            }
            
            saveToLocalStorage();
            resetForm();
          };

          // ç¼–è¾‘ä»»åŠ¡
          const editTask = (task) => {
            // æ·»åŠ å®‰å…¨æ£€æŸ¥
            if (!task) return;
            
            // ä½¿ç”¨æ·±æ‹·è´é¿å…ç›´æ¥ä¿®æ”¹åŸå¯¹è±¡
            Object.assign(currentTask, { ...task });
            editingTask.value = { ...task };
            showAddModal.value = true;
          };

          // å‡†å¤‡åˆ é™¤ä»»åŠ¡ï¼ˆæ˜¾ç¤ºç¡®è®¤æ¨¡æ€æ¡†ï¼‰
          const prepareDeleteTask = (task) => {
            // æ·»åŠ å®‰å…¨æ£€æŸ¥
            if (!task) return;
            
            taskToDelete.value = { ...task }; // ä½¿ç”¨æ·±æ‹·è´
            showDeleteModal.value = true;
          };

          // ç¡®è®¤åˆ é™¤ä»»åŠ¡
          const confirmDelete = () => {
            if (taskToDelete.value) {
              tasks.value = tasks.value.filter(task => task.id !== taskToDelete.value.id);
              saveToLocalStorage();
            }
            showDeleteModal.value = false;
            taskToDelete.value = null;
          };

          // å–æ¶ˆåˆ é™¤
          const cancelDelete = () => {
            showDeleteModal.value = false;
            taskToDelete.value = null;
          };

          // å–æ¶ˆç¼–è¾‘
          const cancelEdit = () => {
            showAddModal.value = false;
            resetForm();
          };

          // é‡ç½®è¡¨å•
          const resetForm = () => {
            // é‡ç½®å“åº”å¼æ•°æ®
            currentTask.title = '';
            currentTask.startDate = '';
            currentTask.endDate = '';
            currentTask.progress = 0;
            editingTask.value = null;
          };

          // æ ¼å¼åŒ–æ—¥æœŸæ˜¾ç¤º
          const formatDate = (dateString) => {
            if (!dateString) return '';
            try {
              return new Date(dateString).toLocaleDateString('zh-CN', {
                year: 'numeric',
                month: '2-digit',
                day: '2-digit',
                hour: '2-digit',
                minute: '2-digit'
              });
            } catch (e) {
              console.error('Error formatting date:', dateString, e);
              return '';
            }
          };
          
          // æ›´æ–°ç”˜ç‰¹å›¾
          const updateGantt = () => {
            // è§†å›¾èŒƒå›´å˜åŒ–æ—¶é‡æ–°è®¡ç®—æ—¶é—´æ§½
          };
          
          // å¤„ç†æ»šåŠ¨åŒæ­¥
          const onScroll = (event) => {
            if (timelineHeader.value) {
              timelineHeader.value.scrollLeft = event.target.scrollLeft;
            }
          };

          // åˆå§‹åŒ–å®Œæˆåæ‰§è¡Œ
          onMounted(() => {
            console.log('Gantt chart component mounted successfully');
          });

          return {
            tasks,
            showAddModal,
            showDeleteModal,
            editingTask,
            taskToDelete,
            viewRange,
            hoveredTaskId,
            hoveredTask,
            showTaskTooltip,
            tooltipTop,
            tooltipLeft,
            timelineHeader,
            ganttBody,
            timeSlots,
            draggingTaskId,
            getTaskStyle,
            getProgressColor,
            showTaskInfo,
            hideTaskInfo,
            startBarDrag,
            handleMouseMove,
            endDrag,
            saveTask,
            editTask,
            prepareDeleteTask,
            confirmDelete,
            cancelDelete,
            cancelEdit,
            formatDate,
            updateGantt,
            onScroll,
            currentTask
          };
        }
      });
      
      // æŒ‚è½½åº”ç”¨
      app.mount('#app');
    }
  </script>
  
  <style>
    /* éšè—æœªç¼–è¯‘çš„æ¨¡æ¿å†…å®¹ç›´åˆ°Vueåº”ç”¨åŠ è½½å®Œæˆ */
    [v-cloak] {
      display: none;
    }
  </style>
</body>
</html>